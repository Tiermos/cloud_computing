Istio Traffic Management Lab Report

1.  Objectives
In this lab, I will deploy the Bookinfo application on a Kubernetes cluster with Istio enabled. I will configure request routing rules to direct traffic to specific versions of the reviews service based on HTTP headers. I will implement traffic shifting to gradually migrate user requests from one service version to another. I will inject artificial delays and HTTP aborts into the request path to simulate downstream failures. I will also define circuit breaking policies to limit the number of concurrent connections and pending requests to a service. These tasks will be carried out using Istio’s VirtualService and DestinationRule custom resources.

2.  Experimental Procedure
2.1 Traffic Shifting Between Service Versions
I first applied the virtual service routing all traffic to reviews:v1 and confirmed on the productpage that no rating stars appeared. Then I updated the route to split traffic 50/50 between reviews:v1 and reviews:v3 using the virtual-service-reviews-50-v3.yaml file, and after refreshing the page multiple times, I observed red stars appearing roughly half the time. Finally, I shifted 100% of traffic to reviews:v3, which consistently displayed red stars on every refresh. Throughout this, I accessed the application via http://localhost:31380/productpage, where 31380 was the NodePort of Istio’s ingress gateway. I learned how Istio’s weight-based routing enables precise, version-level traffic control without changing deployments or scaling pods. This approach gives fine-grained control over canary releases and validation of new service versions in production-like conditions.

2.2 Request Routing Based on User Identity
I first confirmed that all Bookinfo pods, including reviews v1–v3, were running in my Minikube cluster on Docker Desktop. I obtained the ingress gateway’s external IP (127.0.0.1) using kubectl and accessed http://127.0.0.1/productpage, observing inconsistent star ratings due to round-robin routing. I applied virtual-service-all-v1.yaml to route all traffic to v1, which removed the stars entirely. Then I applied virtual-service-reviews-test-v2.yaml to send requests with the header end-user: jason to reviews v2, which restored stars only for that user after login. Through this, I learned how Istio uses VirtualService resources to control traffic based on version subsets and HTTP headers without changing application code.

2.3 Fault Injection with Delays and Aborts
I applied the routing rules to send all traffic to reviews:v1 except for user "jason", who was routed to reviews:v2. I then injected a 7-second delay on requests from "jason" to the ratings service using a VirtualService with fixedDelay: 7s, which caused the productpage to time out after about 6 seconds and show an error. Next, I replaced the delay with an HTTP abort fault (status 500) for the same user, and immediately saw the "Ratings service is currently unavailable" message. Throughout the tests, I accessed the application via the Minikube-provided URL on port 80, and confirmed that only "jason" was affected due to header-based matching on the end-user field. I learned that upstream timeout settings in one microservice can break the entire flow even when downstream services handle delays correctly, and that Istio’s fine-grained fault injection helps expose such integration issues without code changes.

2.4 Circuit Breaking Configuration and Testing
I deployed a fixed version of the httpbin service using the stable image ghcr.io/mccutchen/go-httpbin:v2.4.0, exposing port 8080 and accessed via service port 8000, with CPU and memory limits set to ensure consistent behavior in my Docker Desktop environment. I then applied a DestinationRule with strict circuit breaking settings: maxConnections: 1, http1MaxPendingRequests: 1, and outlier detection triggered by a single 5xx error. Using the fortio client, I sent concurrent requests to http://httpbin:8000/get and observed that increasing concurrency beyond the configured limits resulted in 503 errors, confirming the circuit breaker was active. I learned that Istio enforces connection and request limits at the proxy level, and that application health directly affects upstream availability—without a stable backend, even correct circuit breaker rules can’t function as intended.
3.  Conclusion
I completed all four Istio traffic management tasks using the Bookinfo application.  I learned how to route traffic conditionally, shift load between versions, simulate failures safely, and enforce connection limits.  I became familiar with VirtualService and DestinationRule resources and how they affect runtime behavior.  I observed how changes in Istio configuration immediately impacted application responses without modifying code.  This lab gave me practical experience managing microservice interactions in a service mesh.  I now understand how Istio can support safer deployments and improve system resilience.